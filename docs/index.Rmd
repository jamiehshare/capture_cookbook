--- 
title: "Capture Cookbook üìàüßë‚Äçüç≥"
author: "Capture Intelligence Data Science Team"
date: "*Last updated: `r Sys.Date()`*"
output: 
  rmdformats::readthedown:
    css: custom.css
    toc_depth: 2
    use_bookdown: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      fig.align="center",
                      message = FALSE,
                      warning = FALSE)

library(tidyverse)
library(lubridate)
library(scales)
library(patchwork)
library(ggrepel)
library(ggtext)
library(forcats)
library(gtable)
library(gtExtras)
library(gt)
```

# About the Capture Cookbook 

The aim of this document is to serve as a valuable resource for everyone at SHARE Creative or Capture Intelligence, enabling them to understand the commonly used visualizations created for client projects. It is important to appreciate when and how to use these visualizations, as well as how to interpret them.

The BBC has provided an excellent summary of this topic in their own graphics cookbook:

>A reference manual, rather than a tutorial, it might not tell you how to make your very first chart in R, but is a useful collection of little tips and tricks.

In line with this, this document will not teach you R or the technical aspects of creating these plots. Instead, its primary goal is to help you grasp the purpose and appropriate usage of visualizations in our work. By doing so, it empowers everyone to confidently explain the key insights, strengths, and weaknesses conveyed by different types of plots.

The cookbook begins by introducing various types of visualisations, each serving a specific purpose based on the type of task you want to perform. This approach is adopted because there are often multiple ways to present the same data, and each visualisation has its own merits and drawbacks. Within this section, you will find examples of the business questions we commonly encounter, accompanied by appropriate visualisations and explanations for interpreting them.

Subsequently, there is a section dedicated to enhancing the overall aesthetics of plots. These tips not only contribute to visually pleasing outputs but also assist in effective storytelling. Moreover, they introduce fundamental principles of data visualization that we should all be mindful of.

# Specific Visualisation Purposes

## Trend Over Time

One of the fundamental purposes of data visualisation is to gain insights into how a particular metric or variable has evolved over time. This can be achieved through the use of line charts, which provide a straightforward way of representing trends.

When analysing trends over time, we often focus on metrics such as volume, proportion, or percentage. By plotting these values on a line chart, we can easily observe their fluctuations and patterns.

### Example

```{r, eval = FALSE}
example <- ParseR::sprinklr_export %>% 
  janitor::clean_names() 

write_rds(example, "~/Documents/R/capture_cookbook/data/example.rds")
```

```{r gg-line, fig.cap = 'Line chart showing daily trend'}
example <- read_rds("~/Documents/R/capture_cookbook/data/example.rds")

example %>% 
  mutate(created_time = floor_date(created_time,
                                   unit = "day")) %>% 
  count(created_time) %>% 
  ggplot(aes(x = created_time, y = n)) +
  geom_line(colour = viridis_pal(option = "viridis")(1),
            linewidth = 1) +
  labs(x = "Date",
       y = "Number of posts",
       title = "Line chart showing daily trend") +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())
```

### Intepretation

Interpreting a line chart is relatively simple, but it is crucial to pay attention to the axes in order to fully understand the information being presented. For instance, we need to determine whether the y-axis represents raw values or proportions, and whether the x-axis represents years, months, or another unit of time.

It's important to note that when creating trend plots, we typically need to group the data into intervals that are more easily digestible. This is especially true when working with data from Sprinklr, as the "Created Time" field is recorded down to the nearest second, and it's unlikely that multiple posts are made at the exact same second. The choice of time intervals can significantly impact the interpretation of the plot. Selecting an inappropriate interval may obscure trends or exaggerate their significance.

In the example above, we binned the data on a daily basis. However, if we examine the plot below, which represents the data at a weekly scale, we can see how the view of volume fluctuations becomes less detailed.

```{r gg-line-week, fig.cap = 'Line chart showing weekly trend'}
example %>% 
  mutate(created_time = floor_date(created_time,
                                   unit = "week")) %>% 
  count(created_time) %>% 
  ggplot(aes(x = created_time, y = n)) +
  geom_line(colour = viridis_pal(option = "viridis")(1),
            linewidth = 1) +
  labs(x = "Date",
       y = "Number of posts",
       title = "Line chart showing weekly trend") +
  lims(y = c(0, 4000)) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())
```

It's worth noting that we *can* also present the same data using a bar chart instead of a line chart. The interpretation remains the same, but bar charts may not be as effective at displaying trends. This is because the bars are discrete rather than continuous, and they emphasise the magnitude of individual intervals rather than the overall trend.

Therefore, bar charts can be thought of as more useful when the absolute value of a data point is relevant for understanding a trend, or when we want to supplement an existing line chart with additional information (for example, representing volume alongside the proportion already plotted with time).

```{r gg-bar-trend, fig.cap = 'Bar chart showing weekly trend'}
example %>% 
  mutate(created_time = floor_date(created_time,
                                   unit = "day")) %>% 
  count(created_time) %>% 
  ggplot(aes(x = created_time, y = n)) +
  geom_col(fill = viridis_pal(option = "viridis")(1)) +
  labs(x = "Date",
       y = "Number of posts",
       title = "Bar chart showing weekly trend") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())
```

## Comparing categories

It is often necessary to compare different groups or categories in relation of a specific metric or variable. For instance, we may want to examine the volume of posts for different topics. The crucial aspect here is that these variables we are measuring represent distinct groups and may not follow a logical order (e.g., Platform). In such cases, a bar chart is commonly used and a popular way to go.

### Example

```{r gg-bar, fig.cap = 'Bar chart showing the number of messages per category'}
example %>% 
  count(message_type_2) %>% 
  ggplot(aes(x = message_type_2, y = n)) +
  geom_col(fill = viridis_pal(option = "viridis")(1)) +
  labs(x = "Message Type",
       y = "Number of posts",
       title = "Bar chart showing the number of messages per category") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())
```

#### Intepretation

Similar to the aforementioned trend charts, interpreting a classic bar chart is straightforward. However, there are key modifications we can make to enhance the clarity of the plot and facilitate storytelling.

One such modification involves reordering the categories on the x-axis. We may choose to arrange them alphabetically if that order has been used previously in the project. Alternatively, it can be useful to display the bars in descending order based on the y-axis value, in this case, "Number of posts."

```{r gg-bar-order, fig.cap = 'Bar chart showing the number of messages per category'}
example %>% 
  count(message_type_2) %>% 
  ggplot(aes(x = reorder(message_type_2, desc(n)), y = n)) +
  geom_col(fill = viridis_pal(option = "viridis")(1)) +
  labs(x = "Message Type",
       y = "Number of posts",
       title = "Bar chart showing the number of messages per category") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())
```

A significant challenge with bar plots arises when there are numerous categories. If these categories result in bars of similar lengths, a phenomenon known as the Moir√© effect can occur. This effect leads to confusion and difficulty in focusing, making it challenging to distinguish between individual bars and accurately interpret the data.

```{r gg-bar-moire, fig.cap = 'Bar chart showing the number of messages per category'}
colB <- c(runif(4, min = 50, max = 55),
          runif(4, min = 20, max = 25))

colB <- as_tibble(colB) 

tribble(
  ~colA,
  "a", 
  "b", 
  "c", 
  "d", 
  "e", 
  "f",
  "g",
  "h"
) %>% 
  mutate(colA = toupper(colA),
         colB = colB$value) %>% 
  ggplot(aes(x = colA, y = colB)) +
  geom_col(fill = viridis_pal(option = "viridis")(1)) +
  labs(x = "Category",
       y = "Number of posts",
       title = "Bar chart showing the number of messages per category") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())
```

We observe an example of the Moir√© effect in the bar chart above. It manifests when we start perceiving "patterns" that are not actually present due to sensory overload. Furthermore, charts with more than approximately eight bars, even if they vary in size, can appear cluttered and overwhelming.

##### Lollipop Charts

In order to address this challenge, we can employ lollipop charts to present the data in a different way:

```{r gg-lollipop, fig.cap = 'Lollipop chart showing the number of messages per category'}

tribble(
  ~colA,
  "a", 
  "b", 
  "c", 
  "d", 
  "e", 
  "f", 
  "g", 
  "h"
) %>% 
  mutate(colA = toupper(colA),
         colB = colB$value) %>% 
  ggplot(aes(x = colA, y = colB)) +
  geom_segment(aes(x = colA, xend = colA,
                   y = 0, yend = colB),
               col = "grey50", 
               size = 0.5) +
  geom_point(size = 6,
             col = viridis_pal(option = "viridis")(1)) +
  labs(x = "Category",
       y = "Number of posts",
       title = "Lollipip chart showing the number of messages per category") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())
```

The lollipop chart offers a clearer visual representation that may be (hopefully is) more appealing to you. These charts can also serve as excellent alternatives to bar charts in general, particularly if you find yourself using bar charts excessively in a particular deck. Lollipop charts make better use of white space, avoiding the clutter often associated with busy bar charts.

One important consideration when comparing lollipop charts to bar charts is the level of importance attached to knowing the exact value of each category. In bar charts, it is evident where the top of the bar is located, but with lollipop charts, determining whether the centre, top, or bottom of the circle represents the value in question can be somewhat imprecise. To address this, it is possible to include the raw values directly on the lollipop chart. Despite this, it remains essential to consider the intended audience and the key message we aim to convey, whether it pertains to general trends or specific values.

#### Pie Charts

While pie charts are commonly used and provide a sense of familiarity, they are rarely the optimal choice for representing our data. Nevertheless, we often receive requests to include pie charts when comparing categories.

**Pie charts are most effective when** when values are approximately 25%, 50%, or 75%. These percentages are easier to interpret within a pie chart compared to a stacked bar chart.

```{r gg-pie, fig.cap = 'When a pie chart is better than a stacked bar chart', out.width="60%"}
bar <- tribble(
  ~colA, ~colB,
  "a", 22,
  "b", 30,
  "c", 48
) %>% 
  mutate(colA = toupper(colA)) %>% 
  ggplot(aes(x = 0, y = colB, fill = colA)) +
  geom_col() +
  scale_fill_viridis_d() +
  labs(x = "Category",
       y = "Number of posts",
       title = "Not ideal") +
  lims(x = c(-1, 1)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 25, hjust = 0.5),
        panel.border = element_blank(),
        # axis.line = element_line(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.position = "none",
        panel.grid = element_blank())

pie <- tribble(
  ~colA, ~colB,
  "a", 22,
  "b", 30,
  "c", 48
) %>% 
  mutate(colA = toupper(colA)) %>% 
  ggplot(aes(x = 1, y = colB, fill = colA)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0) +
  scale_fill_viridis_d() +
  labs(title = "Better") +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 25, hjust = 0.5),
        panel.border = element_blank(),
        # axis.line = element_line(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.position = "none",
        panel.grid = element_blank())

bar + pie
```

**Pie charts are not suitable** when we want clients to be able to accurately compare the size of different segments.

```{r, gg-pie-2, fig.cap = 'When a bar chart is better than a pie bar chart', out.width="60%"}
bar <- tribble(
  ~colA, ~colB,
  "a", 45,
  "b", 40,
  "c", 52,
  "d", 50,
  "e", 47,
) %>% 
  mutate(colA = toupper(colA)) %>% 
  ggplot(aes(x = colA, y = colB, fill = colA)) +
  geom_col() +
  scale_fill_viridis_d() +
  labs(title = "Good") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 25, hjust = 0.5),
        panel.border = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.position = "none",
        panel.grid = element_blank())

pie <- tribble(
  ~colA, ~colB,
  "a", 45,
  "b", 40,
  "c", 52,
  "d", 50,
  "e", 47,
) %>% 
  mutate(colA = toupper(colA)) %>% 
  ggplot(aes(x = 1, y = colB, fill = colA)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0) +
  scale_fill_viridis_d() +
  labs(title = "Bad") +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 25, hjust = 0.5),
        panel.border = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.position = "none",
        panel.grid = element_blank())

bar + pie
```

This limitation can be somewhat mitigated by directly adding values onto the plot, but we will delve into that aspect later in this cookbook

#### Doughnut Charts

The sibling of the Pie Chart, a doughnut chart displays the same information as a pie chart though the centre is removed. This allows information to be reported within the centre of the chart itself. However, whereas the proportion of slices represents the values of interest in pie charts, doughnut charts use the length of each arc to represent the values being presented. The same precautions should be kept in mind when making and presenting doughnut chart as mentioned above for pie charts (in fact, if anything, the number of categories that can appropriately be displayed is lower- up to 5).

```{r gg-doughnut, fig.cap = 'Comparison between a Pie Chart and a Doughnut Chart. Both charts present the same data', out.width="60%"}
pie <- tribble(
  ~colA, ~colB,
  "a", 22,
  "b", 30,
  "c", 48
) %>% 
  mutate(colA = toupper(colA)) %>% 
  ggplot(aes(x = 2, y = colB, fill = colA)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0) +
  scale_fill_viridis_d() +
  labs(title = "Pie Chart") +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 25, hjust = 0.5),
        panel.border = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.position = "none",
        panel.grid = element_blank())

doughnut <- tribble(
  ~colA, ~colB,
  "a", 22,
  "b", 30,
  "c", 48
) %>% 
  mutate(colA = toupper(colA)) %>% 
  ggplot(aes(x = 2, y = colB, fill = colA)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0) +
  xlim(-0.5, 2.5) +
  scale_fill_viridis_d() +
  labs(title = "Doughnut Chart") +
  annotate(geom = 'text', x = -0.5, y = 0, label = "Number of posts: \nX posts",
           family = "GT Walsheim Pro",
           size = 6) +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 25, hjust = 0.5),
        panel.border = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.position = "none",
        panel.grid = element_blank())

pie + doughnut
```

## Comparing sub-categories within categories 

A stacked bar chart can be a valuable tool for gaining deeper insights beyond a simple bar chart. It allows us to understand the relative composition of each bar (i.e. category) by considering the levels of a second categorical variable nested within.

In the context of our marketing company, stacked bar charts can help us answer important business questions. For example, we can use them to visualize how sentiment varies between different topics or brands, or any other categorical variable of interest.

A key business question that may be answered with this is to visualise how sentiment varies between between topics or brands, or any other categorical variable of interest.

### Example

```{r gg-stacked, fig.cap = 'Stacked bar chart showing sentiment volume per category'}
tribble(
  ~colA, ~pos, ~neu, ~neg,
  "A", 25, 50, 25,
  "B", 15, 60, 25,
  "C", 17, 40, 43,
  "D", 60, 10, 30,
) %>% 
  rowwise() %>% 
  mutate(pos = case_when(colA == "A" ~ pos * 2,
                          colA == "B" ~ pos * 0.2,
                          colA == "C" ~ pos * 0.5,
                          colA == "D" ~ pos * 2.7,
                         T ~ pos),
         neu = case_when(colA == "A" ~ neu * 2,
                          colA == "B" ~ neu * 0.2,
                          colA == "C" ~ neu * 0.5,
                          colA == "D" ~ neu * 2.7,
                         T ~ neu),
         neg = case_when(colA == "A" ~ neg * 2,
                          colA == "B" ~ neg * 0.2,
                          colA == "C" ~ neg * 0.5,
                          colA == "D" ~ neg * 2.7,
                         T ~ neg)) %>% 
  pivot_longer(cols = c(pos, neu, neg), 
               names_to = "sentiment",
               values_to = "count") %>% 
  mutate(sentiment = factor(sentiment, levels = c("pos", "neu", "neg"))) %>% 
  ggplot(aes(x = colA, y = count, fill = sentiment)) +
  geom_bar(position = "stack", stat = "identity") +
  labs(x = "Category",
       y = "Number of posts classified per topic",
       title = "Stacked bar chart showing sentiment volume per category") +
  # scale_fill_viridis_d(direction = -1,
  #                      option = "C",
  #                      labels = c("Positive", "Neutral", "Negative")) +
  scale_fill_manual(values = c("#1B7837", "grey", "#762A83"),
                               labels = c("Positive", "Neutral", "Negative")) +
  # scale_fill_manual(values = c("#53BAA4", "#D9D6B2", "#E09A44"),
  #                              labels = c("Positive", "Neutral", "Negative")) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())
```

### Interpretation

Interpreting stacked bar charts requires careful consideration, especially when presenting them to clients who may not be familiar with this type of visualisation. It may not be immediately clear to clients whether each stack starts from the same baseline, such as the purple stack in our case (which starts at 0), or if it starts from the top of the stack below (as it does in our case).

Comparing stacks between different categories can also be challenging. While it's evident which category contains the largest number of negative posts in the baseline stack (purple), it becomes more difficult to compare the neutral and positive stacks since they don't share the same baseline (ask yourself, are there more neutral posts in category C or D- it's not clear is it?). Being mindful of this limitation is crucial. Finally, stacked bar charts can be particularly challenging to interpret when the total bar size varies significantly. In such cases, the individual stacks can become squashed, making it harder to discern the relative proportions accurately.

```{r gg-stacked-perc, fig.cap = 'Stacked bar chart showing sentiment percentage per category'}
tribble(
  ~colA, ~pos, ~neu, ~neg,
  "A", 25, 50, 25,
  "B", 15, 60, 25,
  "C", 17, 40, 43,
  "D", 60, 10, 30,
) %>% 
  pivot_longer(cols = c(pos, neu, neg), 
               names_to = "sentiment",
               values_to = "count") %>% 
  mutate(sentiment = factor(sentiment, levels = c("pos", "neu", "neg"))) %>% 
  ggplot(aes(x = colA, y = count, fill = sentiment)) +
  geom_bar(position = "stack", stat = "identity") +
  labs(x = "Category",
       y = "Percentage of posts classified per topic",
       title = "Stacked bar chart showing sentiment percentage per category") +
  # scale_fill_viridis_d(direction = -1,
  #                      option = "C",
  #                      labels = c("Positive", "Neutral", "Negative")) +
  scale_fill_manual(values = c("#1B7837", "grey", "#762A83"),
                               labels = c("Positive", "Neutral", "Negative")) +
  # scale_fill_manual(values = c("#53BAA4", "#D9D6B2", "#E09A44"),
  #                              labels = c("Positive", "Neutral", "Negative")) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())
```

To address the potential challenges mentioned above, we can scale our data to show proportions or percentages of posts with each sentiment per category, rather than raw volumes. This approach makes it much easier to compare the sentiment makeup of categories with lower volume. However, it's essential to note that scaling the data in this way may lead clients to overlook the fact that each bar represents vastly different volumes in reality.

To navigate this potential pitfall, it is crucial to provide clear explanations of what the chart represents, whether it shows volume or proportion, and to determine a specific narrative or story that the visualisation aims to convey (such as comparing sentiments *between* categories or exploring sentiment variations *within* a specific category).

## Visualise distribution of a continuous variable

Sometimes we will want to understand the distribution of a **continuous variable** in our data to gain insights. For instance, if we have calculated valence using the ParseR package, we might want to examine the distribution. Although these types of visualizations are typically used for exploratory data analysis (EDA) rather than client presentations, it is still an extremely powerful and useful string to have in your data exploration bow.

### Example

```{r gg-hist, fig.cap = 'Histogram showing the (normal) distribution of sentiment'}
# Generate sample data for normal distribution
set.seed(123)
normal_data <- tibble(x = rnorm(1000, mean = 0.5, sd = 0.1))

normal_data %>%
  ggplot(aes(x = x)) +
  geom_histogram(fill = viridis_pal(option = "viridis")(1)) +
  labs(title = "Histogram showing the (normal) distribution of sentiment") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  labs(x = "Sentiment Score") +
  lims(x = c(0, 1)) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())
```

### Interpretation

Histograms are graphical representations that consist of bars, with each bar representing a specific range of values for the variable we are visualising (e.g., the x-axis of Sentiment Score). When interpreting a histogram, it is essential to consider the shape, centre, and spread of the distribution. The shape can be symmetric (normal), skewed to the left or right, or exhibit bimodal characteristics (two peaks). The centre can be determined using the mean or median, while the spread can be represented by the standard deviation or range. Histograms offer several benefits, such as identifying outliers, understanding data range and variability, and comparing variable distributions across different groups. Similar to our "trends over time" plots, it is important to select an appropriate bin width or value range for each bar when creating a histogram, as this choice can influence the interpretation of the distribution.

To provide clarity, let's examine histograms depicting a *left-skewed*, *right-skewed*, and *bimodal* distribution:

```{r gg-hist-2, fig.cap = 'Histograms revealing different underlying distributions within data'}
# Generate sample data for left-skewed distribution
set.seed(123)
left_skewed_data <-   tibble(x = rnorm(1000, mean = 0.8, sd = 0.1)) %>% 
  filter(x <= 1)


left_skewed_dist <- left_skewed_data %>%
  ggplot(aes(x = x)) +
  geom_histogram(fill = viridis_pal(option = "viridis")(1)) +
  labs(title = "Left-skewed distribution") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  labs(x = "Sentiment Score") +
  lims(x = c(0, 1)) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())

# Generate random data with right-skewed distribution
set.seed(123)
right_skewed_data <- tibble(x = abs(rnorm(1000, mean = 0.2, sd = 0.1))) 


right_skewed_dist <- right_skewed_data %>%
  ggplot(aes(x = x)) +
  geom_histogram(fill = viridis_pal(option = "viridis")(1)) +
  labs(title = "Right-skewed distribution") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  labs(x = "Sentiment Score") +
  lims(x = c(0, 1)) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())

# Generate random data with bimodal distribution
set.seed(123)
bimodal_data <- tibble(x = c(rnorm(500, mean = 0.3, sd = 0.1), rnorm(500, mean = 0.7, sd = 0.1))) %>%   
  filter(x <= 1,
         x >= 0)

bimodal_dist <- bimodal_data %>%
  ggplot(aes(x = x)) +
  geom_histogram(fill = viridis_pal(option = "viridis")(1)) +
  labs(title = "Bimodal distribution") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  labs(x = "Sentiment Score") +
  lims(x = c(0, 1)) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())


left_skewed_dist / right_skewed_dist / bimodal_dist 
```

From these examples, our interpretation should be that the left-skewed distribution appears as a curve skewed to the left, with most values clustered towards the upper end of our scale (closer to 1). On the other hand, the right-skewed distribution appears as a curve skewed to the right, with most values clustered towards the lower end (closer to 0). Lastly, the bimodal distribution displays two distinct peaks, with most values concentrated around two different means (0.3 and 0.7 in this particular example).

## Visualise most frequent terms

The objective of a bigram network is to provide a comprehensive overview of a specific conversation by identifying frequently occurring pairs of words.

N.B. The term *bi*-gram refers to a sequence of two adjacent terms. If we were to examine three adjacent terms, this would be referred to as a *tr*-igram, and so on. In other words, a bigram specficially refers to an *n*-gram where n = 2. The plot we present is known as a bigram *network*, which displays these pairs of words. Whilst it may seem like splitting hairs, it is important to be precise in our terminology.

### Example

```{r, eval=FALSE}
# Generate a sample
set.seed(1)
example2 <- ParseR::sprinklr_export %>%
  dplyr::slice_sample(n = 1000) %>% 
  janitor::clean_names()

counts <- example2 %>%
  ParseR::count_ngram(text_var = message, 
                      n = 2, 
                      top_n = 25,
                      clean_text = TRUE,
                      remove_stops = TRUE)

write_rds(counts, "~/Documents/R/capture_cookbook/data/counts.rds")
```

```{r gg-bigram, fig.cap = 'Bigram network showcasing frequently appearing bigram within a dataset'}
counts <- read_rds("~/Documents/R/capture_cookbook/data/counts.rds")

set.seed(123)
counts %>%
  purrr::pluck("viz") %>%
  ParseR::viz_ngram(emphasis = TRUE)
```

### Interpretation

Interpreting a bigram network is more complex compared to the simpler plots we have previously discussed. Each word is represented by both a label and a node (circle), with edges (arrows) between terms representing the direction a bigram should be read. The colour of the nodes represents the frequency of the individual terms, while the colour of the edges represents the frequency of the bigrams. Additionally, the size of the nodes corresponds to the frequency of the individual terms. This size distinction can serve as an initial guide to identify frequently occurring words. Finally, it is important to note that the physical placement of the nodes holds no significance; their arrangement is determined by an algorithm based on their connections. For instance, the bigram "join us" is no more similar to "every day" than it is to "annual Hispanic".

For a more detailed overview of bigrams and more specific business-specific interpretation, please see the [ParseR vignette](http://parser.shareldn.com/articles/ngrams.html)

## Differences in language between categories

Often we will be interested in comparing language use between groups/categories. These categories could be audiences, posts of differing sentiment, posts from different quarters etc.If we can classify different posts into distinct groups, we can compare language.

### Example

```{r gg-wlo, eval=FALSE, fig.cap = 'Weighted Log Odds plots showing different word usage between two categories- Male and Female'}
example3 <- example %>% 
  ParseR::clean_text(text_var = message) %>% 
  dplyr::mutate(message = tm::removeWords(x = message, c(tm::stopwords(kind = "SMART"), 
                                              "ll", "de", "don", "ve", "didn", "doesn", 
                                              "isn", "bit", "ly", "pic", "htt"))) %>% 
  dplyr::filter(sender_gender != 'NA') %>% 
  mutate(sender_gender = case_when(sender_gender == "F" ~ "Female",
                                   sender_gender == "M" ~ "Male",
                                   T ~ sender_gender))

wlos <- ParseR::calculate_wlos(example3, 
                               topic_var = sender_gender,
                               text_var = message,
                               top_n = 30)

write_rds(wlos, "~/Documents/R/capture_cookbook/data/wlos.rds")
```

```{r}
wlos <- read_rds("~/Documents/R/capture_cookbook/data/wlos.rds")

wlos$viz
```

### Interpretation

Before getting bogged down by the statistical interpretation of WLO, let's think about this from a data visualisation point of view. WLO charts are essentially scatter plots that depict word frequency on the x-axis and the log odds ratio on the y-axis. Each point on the scatter plot represents a word, with labels applied to identify them. Things get a little trickier when we take a look at the x axis and realise it is on a logarithmic scale- meaning the distance between 1 and 10 on this scale would be the same as between 10 and 100 (although WLO x-axes typically don't start at 0 for clarity).

For a more comprehensive understanding of WLO and its statistical interpretation, please refer to the [ParseR vignette](http://parser.shareldn.com/articles/distinctness_in_text.html)

Despite the complexity involved, it's crucial to emphasize that the magnitude of a WLO value indicates the strength of the association *but is not directly interpretable as a probability or frequency*. Instead, it represents the logarithmic difference between two probabilities (or odds) and should be treated as a relative measure of association.

Therefore, when reporting WLO to clients, one must refrain from using phrases such as "This term is X times as likely to appear in Category A than Category B and C". Instead use phrases such as "**This term has a stronger association with Category A than Category B and C**".

## Comparing two categorical variables with a metric of interest

Heatmaps are powerful visualisations that use colours to help us identify patterns in the value of a metric for one or two categorical variables. They offer great versatility and can be employed for various purposes, all aimed at addressing specific business questions by examining color intensity in different areas of the heatmap.

For instance, heatmaps can be utilized to determine the topics in which certain brands are mentioned more frequently, or to identify specific time periods when discussions are more intense.

### Example

```{r gg-heatmap, fig.cap = 'Example heatmap showing branded conversation within different topics'}
x <- LETTERS[1:6]
y <- paste0("Topic ", seq(1, 5))

set.seed(1234)
data <- expand.grid(x = x, y = rev(y)) %>%
  rename(brand = x,
         topic = y) %>% 
  mutate(z = round(runif(30, 1, 100)),
         z_t = case_when(brand == "A" ~ z * 8,
                       T ~ z),
         z_t = case_when(brand == "E" & topic == "Topic 4" ~ z_t * 5,
                         brand == "D" ~ z_t * 0.3,
                         T ~ z_t)) %>% 
  group_by(topic) %>% 
  mutate(z_prop = z_t / sum(z_t),
         z_prop2 = z / sum(z)) %>% 
  ungroup()

data %>% 
  ggplot(aes(brand, topic, fill = z_prop)) + 
  geom_tile() +
  labs(x = "Brand",
       y = NULL,
       fill = "Percentage of Topic conversation that includes each Brand",
       title = "Topic x Brand Heatmap") +
  scale_fill_viridis_c(direction = -1,
                       labels = percent) +
  guides(fill = guide_colorbar(title.position = 'top',
                               direction = "horizontal",
                               title.hjust = .5,
                               barwidth = 22,
                               barheight = 0.8)) +
  coord_fixed() +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "bottom",
        legend.text = element_text(size = 7),
        legend.title = element_text(hjust = 0.5))
```

### Interpretation

The heatmap displayed above illustrates the distribution of brand mentions across different topics. Each row represents a topic, and if we were to sum the values in each cell, the total for each row would equal 100%, while this wouldn't hold true for each column.

The x-axis represents different brands, while the y-axis represents different topics. Each colored cell represents the percentage of conversation within each topic that includes mentions of a specific brand.

Heatmaps are particularly useful for providing a generalized view of the data rather than an overly precise representation. Consequently, during interpretation, it is more appropriate to observe general patterns rather than focusing on specific values. For example, we can observe that Brand A is highly popular (darker colours) and is frequently mentioned in conversations for all topics except Topic 4. Additionally, Brand E stands out prominently in Topic 4, dominating the branded conversation within that topic (darker colour). Conversely, Brands D and F appear with much lower percentages in all topics (indicated by lighter colours in the Brand D column).

To further illustrate the interpretation of heatmaps, let's consider the following example. The heatmap shown here effectively functions as a calendar, with each row representing a different day and each column representing an hour of the day. We can interpret this plot as depicting the proportion of branded conversations occurring at different times throughout the week. Immediately, two clear patterns emerge. Firstly, for each day, the majority of users posting about this brand do so between 16:00 and 21:00 (indicated by darker colours when reading rows from left to right). Secondly, when comparing the days, we observe that Saturday and Sunday have more posts at most hours than weekdays (indicated by darker coluors when reading columns up and down).

```{r gg-heatmap-2, fig.cap = 'Example heatmap showing hourly social media brand mentions for each day of the week'}
x <- 1:10000
days <- factor(c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"), 
               levels = rev(c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")), 
               ordered = TRUE)

day <- sample(days, 10000, TRUE, 
              c(0.5, 0.8, 0.8, 0.6, 0.5, 0.2, 0.3))

set.seed(1234)
hour <- round(rbeta(10000, 1, 2, 6) * 23) + 1

data.frame(x, hour, day) %>% 
  group_by(day, hour) %>% 
  summarise(n = n()) %>% 
  mutate(perc = n/sum(n),
         perc = case_when(day == "Sat" | day == "Sun" ~ perc * 1.5,
                          T ~ perc)) %>% 
  ggplot(aes(factor(hour), day, fill = perc)) + 
  geom_tile() +
  labs(x = "Time of Day",
       y = NULL,
       fill = "Percentage of posts about Brand",
       title = "Heatmap of Hourly Social Media Usage") +
  scale_fill_viridis_c(direction = -1,
                       labels = percent) +
  scale_x_discrete(breaks = 1:24, labels = 1:24) +
  guides(fill = guide_colorbar(title.position = 'top',
                               direction = "horizontal",
                               title.hjust = .5,
                               barwidth = 10,
                               barheight = 0.8)) +
  coord_fixed() +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "bottom",
        legend.text = element_text(size = 7),
        legend.title = element_text(hjust = 0.5))
```

## Presenting precise numerical values

Sometimes we need to provide a comprehensive view of the data and allow the reader to examine the exact values of our analyses and make detailed comparisons themselves. Therefore, if precision is crucial for your analysis and you want to provide specific values or facilitate precise calculations, a table may be more appropriate. Tables can also be suitable when we want to either summarise a lot of information that would require multiple charts over multiple slides.

The use cases for tables are almost infinite- this makes sense as every chart we make is based on a table which we could, unwisely, present in lieu of a chart. But let's start with a simple example:

```{r, eval=F}
cookbook_gt <- read_rds("~/Documents/R/capture_cookbook/data/gt_topic.rds")

viridis <- viridis_pal(option = "viridis", direction = -1)(4)

var_1_pal <- col_numeric(c("#f7f7f7", viridis[1]), domain = c(0, 1), alpha = 0.75)
var_2_pal <- col_numeric(c("#f7f7f7", viridis[2]), domain = c(0, 1), alpha = 0.75)
var_3_pal <- col_numeric(c("#f7f7f7", viridis[3]), domain = c(0, 1), alpha = 0.75)
var_4_pal <- col_numeric(c("#f7f7f7", viridis[4]), domain = c(0, 1), alpha = 0.75)

cookbook_gt %>% 
  select(topic, var_1, var_2, var_3, var_4) %>% 
  gt() %>% 
  tab_header(title = "Example table") %>%
  fmt_number(columns = c(var_1, var_2, var_3, var_4), sep_mark = ",", decimals = 2) %>%
  tab_source_note(source_note = md("We can write relevant information in a source note.  \nData from XYZ.  \nDarker colours represent higher values for each variable")) %>%
  opt_table_font(font = "GT Walsheim Pro") %>%
  tab_style(style = cell_text(weight = "600",
                              align = "center"), 
            locations = cells_title(groups = "title")) %>% 
  tab_style(style = cell_text(color = "grey50",
                              transform = "capitalize"), 
            locations = cells_column_labels(everything())) %>% 
  cols_align(align = "left") %>% 
  tab_options(
    column_labels.border.top.width = px(3),
    column_labels.border.top.color = "transparent",
    #Remove border around table
    table.border.top.color = "transparent",
    table.border.bottom.color = "transparent",
    #Adjust font sizes and alignment
    source_notes.font.size = 12,
    heading.align = "left"
    ) %>% 
  gtsave("~/Documents/R/capture_cookbook/img/gt_table.png", vwidth = 2500, expand = 20)
```
<center>

![](../img/gt_table.png){width=50%}

</center>

### Interpretation

There isn't too much to explain in interpreting tables. Instead, we will focus on some good tips when designing tables.

* Tables become more readable the fewer columns they have. Careful consideration of the most important information necessary to portray will improve legibility.
* Try to reduce the width of columns to help legibility. This includes reducing the column heading length but also using abbreviations or appropriate precision of values (e.g. report 3.14 rather than 3.141592)
* Sort the table by something appropriate. Whilst it might appear that sorting alphabetically is suitable, it rarely brings the most import data to the top. Often we might want to sort by volume, sentiment, or another value that supports the killer take-home message. We can see what our table now looks like if sorted by Var_1:

```{r, eval=F}
cookbook_gt %>%
  select(topic, var_1, var_2, var_3, var_4) %>% 
  arrange(desc(var_1)) %>%
  mutate(topic = reorder(topic, var_1)) %>% 
  gt() %>% 
  tab_header(title = "Example table") %>%
  fmt_number(columns = c(var_1, var_2, var_3, var_4), sep_mark = ",", decimals = 2) %>%
  tab_source_note(source_note = md("We can write relevant information in a source note.  \nData from XYZ.  \nDarker colours represent higher values for each variable")) %>%
  opt_table_font(font = "GT Walsheim Pro") %>%
  tab_style(style = cell_text(weight = "600",
                              align = "center"), 
            locations = cells_title(groups = "title")) %>% 
  tab_style(style = cell_text(color = "grey50",
                              transform = "capitalize"), 
            locations = cells_column_labels(everything())) %>% 
  cols_align(align = "left") %>% 
  tab_options(
    column_labels.border.top.width = px(3),
    column_labels.border.top.color = "transparent",
    #Remove border around table
    table.border.top.color = "transparent",
    table.border.bottom.color = "transparent",
    #Adjust font sizes and alignment
    source_notes.font.size = 12,
    heading.align = "left"
    )  %>% 
  gtsave("~/Documents/R/capture_cookbook/img/gt_table_2.png", vwidth = 2500, expand = 20)
```

<center>

![](../img/gt_table_2.png){width=50%}

</center>
* We can apply charts to tables! Yes, yes, I know this section was supposed to be about tables not charts, but we can add simple charts known as sparklines to show clear trends within tables. These charts are obviously not very detailed as they need to sit in a small space, but can provide a nice compliment to the other values presented in the table.

```{r, eval=F}
cookbook_gt %>% 
  gt() %>%
  tab_header(title = "Example table") %>%
  fmt_number(columns = c(var_1, var_2, var_3, var_4), sep_mark = ",", decimals = 2) %>%
  tab_source_note(source_note = md("We can write relevant information in a source note.  \nData from XYZ.  \nDarker colours represent higher values for each variable")) %>%
  opt_table_font(font = "GT Walsheim Pro") %>%
  tab_style(style = cell_text(weight = "600",
                              align = "center"), 
            locations = cells_title(groups = "title")) %>% 
  tab_style(style = cell_text(color = "grey50",
                              transform = "capitalize"), 
            locations = cells_column_labels(everything())) %>% 
  cols_align(align = "left") %>% 
  cols_align(align = "center",
             columns = c(`Volume over time`)) %>%
  tab_options(
    column_labels.border.top.width = px(3),
    column_labels.border.top.color = "transparent",
    #Remove border around table
    table.border.top.color = "transparent",
    table.border.bottom.color = "transparent",
    #Adjust font sizes and alignment
    source_notes.font.size = 12,
    heading.align = "left"
    ) %>% 
  gtExtras::gt_plt_sparkline(`Volume over time`,
                             label = F) %>% 
  gtsave("~/Documents/R/capture_cookbook/img/gt_table_3.png", vwidth = 2500, expand = 20)
```

<center>

![](../img/gt_table_3.png){width=60%}

</center>
* Add colour to the table. We can apply our heatmap principles from the section above to colour our table similar to a heatmap. This can either be done on a column by column basis (with different colours per columns), or by across multiple columns if they show the same variable (e.g. sentiment percentage in January [Column 1], February [Column 2], March (Column 3]). Bear in mind that there will be no legend, so it should be clear what the colours present - high numbers should be darker.

```{r, eval=F}
cookbook_gt %>% 
  gt() %>%
  tab_header(title = "Example table") %>%
  data_color(
    columns = var_1,
    palette = var_1_pal) %>%
  data_color(
    columns = var_2,
    palette = var_2_pal) %>%
  data_color(
    columns = var_3,
    palette = var_3_pal) %>%
  data_color(
    columns = var_4,
    palette = var_4_pal) %>%
  fmt_number(columns = c(var_1, var_2, var_3, var_4), sep_mark = ",", decimals = 2) %>%
  tab_source_note(source_note = md("We can write relevant information in a source note.  \nData from XYZ.  \nDarker colours represent higher values for each variable")) %>%
  opt_table_font(font = "GT Walsheim Pro") %>%
  tab_style(style = cell_text(weight = "600",
                              align = "center"), 
            locations = cells_title(groups = "title")) %>% 
  tab_style(style = cell_text(color = "grey50",
                              transform = "capitalize"), 
            locations = cells_column_labels(everything())) %>% 
  cols_align(align = "left") %>% 
  cols_align(align = "center",
             columns = c(`Volume over time`)) %>%
  tab_options(
    column_labels.border.top.width = px(3),
    column_labels.border.top.color = "transparent",
    #Remove border around table
    table.border.top.color = "transparent",
    table.border.bottom.color = "transparent",
    #Adjust font sizes and alignment
    source_notes.font.size = 12,
    heading.align = "left"
    ) %>% 
  gtExtras::gt_plt_sparkline(`Volume over time`,
                             label = F) %>% 
  gtsave("~/Documents/R/capture_cookbook/img/gt_table_4.png", vwidth = 2500, expand = 20)
```

<center>

![](../img/gt_table_4.png){width=60%}

</center>

# Chart Aesthetic Tips

The following are good data viz practices that should be kept in mind whenever we make a chart. Clients may request charts that go against these practices and principles, but it is important to be aware of such principles in our quest for making beautiful looking Capture Intelligence plots.

## Adding values to plot directly

Sometimes we might want a really clean looking plot, or fully transparency of the exact value being visualised is paramount. 

In this case, also including the raw values directly onto a figure can be extremely useful. Here we take the same bar chart we introduced earlier in the Cookbook but include the specific values that each of our bars represents as a label. Because we include these values, we can also remove our y axis as well as any plot gridlines as they no longer help us discern more information from the plot. 

```{r gg-value, fig.cap = 'Bar chart showing the number of messages per category'}
example %>% 
  count(message_type_2) %>% 
  ggplot(aes(x = message_type_2, y = n)) +
  geom_col(fill = viridis_pal(option = "viridis")(1)) +
  geom_text(aes(label = n), 
            vjust = 1.5,
            colour = "white",
            size = 4,
            family = "GT Walsheim Pro") +
  labs(x = "Message Type",
       y = NULL,
       title = "Bar chart showing the number of messages per category") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line(),
        axis.line.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        panel.grid = element_blank())
```

As mentioned in the pie chart section (REF), adding labels is highly recommended for pie charts and donught charts:

```{r gg-value-2, fig.cap = 'Comparison between a Pie Chart and a Doughnut Chart showing the same data'}
pie <- tribble(
  ~colA, ~colB,
  "a", 22,
  "b", 30,
  "c", 48
) %>% 
  mutate(colA = toupper(colA),
         colC = cumsum(rev(colB)),
         colD = (colC + lag(colC, default = 0)) / 2) %>% 
  ggplot(aes(x = 2, y = colB, fill = colA)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0) +
  scale_fill_viridis_d() +
  geom_text(aes(y = colD, label = paste0(colB, "%")), 
            x = 2.63,
            colour = "black",
            size = 5,
            family = "GT Walsheim Pro") +
  labs(title = "Pie Chart") +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.position = "none",
        panel.grid = element_blank())

doughnut <- tribble(
  ~colA, ~colB,
  "a", 22,
  "b", 30,
  "c", 48
) %>% 
  mutate(colA = toupper(colA),
         colC = cumsum(rev(colB)),
         colD = (colC + lag(colC, default = 0)) / 2,
         sum_posts = sum(colB)) %>% 
  ggplot(aes(x = 2, y = colB, fill = colA)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0) +
  xlim(-0.5, 2.5) +
  scale_fill_viridis_d() +
  labs(title = "Doughnut Chart") +
  annotate(geom = 'text', x = -0.5, y = 0, label = paste0("Number of posts: \n", 100, " posts"),
           family = "GT Walsheim Pro", size = 6) +
  geom_text(aes(y = colD, label = paste0(colB, "%")), 
            x = 2.9,
            colour = "black",
            size = 5,
            family = "GT Walsheim Pro") +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.position = "none",
        panel.grid = element_blank())

pie + doughnut
```

## Adding labels to the plot directly

Similarly, it is often good practice to add a category label directly to the plot too to avoid having a legend. This is because in general legends take too long to read (ones eyes have to go back and forth between legend and plot), they don't work great with many colours, and decrease accessibility of our plots.

For example, let's see a plot where we have a legend:

```{r gg-nolabel, fig.cap = 'Line chart showing daily trend of three categories'}
set.seed(1234)
example %>% 
  mutate(created_time = floor_date(created_time,
                                   unit = "day")) %>% 
  count(created_time) %>% 
  mutate(a = as.integer(n * runif(n = nrow(.), min = 0.1, max = 2) + 150),
         b = as.integer(rev(a) * runif(n = nrow(.), min = 0.5, max = 1))) %>% 
  pivot_longer(cols = c(n, a, b), values_to = "value") %>% 
  mutate(name = case_when(name == "n" ~ "Category A",
                          name == "b" ~ "Category B",
                          T ~ "Category C")) %>% 
  mutate(label = if_else(created_time == max(created_time), as.character(name), NA_character_),
         created_time = as_date(created_time)) %>%
  ggplot(aes(x = created_time, y = value)) +
  geom_line(aes(colour = name),
            linewidth = 1) +
  scale_colour_manual(values = c(viridis_pal(option = "viridis")(1),
                                 viridis_pal(option = "viridis")(10)[5],
                                 viridis_pal(option = "viridis")(10)[9])) +
  lims(x = c(as_date("2018-10-15"), as_date("2018-11-03"))) +
  labs(x = "Date",
       y = "Number of posts",
       title = "Line chart showing daily trend of three categories",
       colour = "Category") +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())
```

Notice how you have to keep looking between the plot and the legend to fully understand which line represents which category? 

When we plot the category label directly on the figure, this mental load is removed:

```{r gg-label, fig.cap = 'Line chart showing daily trend of three categories'}
set.seed(1234)
example %>% 
  mutate(created_time = floor_date(created_time,
                                   unit = "day")) %>% 
  count(created_time) %>% 
  mutate(a = as.integer(n * runif(n = nrow(.), min = 0.1, max = 2) + 150),
         b = as.integer(rev(a) * runif(n = nrow(.), min = 0.5, max = 1))) %>% 
  pivot_longer(cols = c(n, a, b), values_to = "value") %>% 
  mutate(name = case_when(name == "n" ~ "Category A",
                          name == "b" ~ "Category B",
                          T ~ "Category C")) %>% 
  mutate(label = if_else(created_time == max(created_time), as.character(name), NA_character_),
         created_time = as_date(created_time)) %>%
  ggplot(aes(x = created_time, y = value)) +
  geom_line(aes(colour = name),
            linewidth = 1) +
  # scale_colour_viridis_d(direction = -1) +
  scale_colour_manual(values = c(viridis_pal(option = "viridis")(1),
                                 viridis_pal(option = "viridis")(10)[5],
                                 viridis_pal(option = "viridis")(10)[9])) +
  geom_text(aes(label = label, colour = label),
            nudge_x = 1.5,
            vjust = -0.1,
            na.rm = TRUE,
            family = "GT Walsheim Pro",
            size = 5) +
  lims(x = c(as_date("2018-10-15"), as_date("2018-11-03"))) +
  labs(x = "Date",
       y = "Number of posts",
       title = "Line chart showing daily trend of three categories") +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.position = "none")
```

## Gridlines and borders - WIP

We should aim to remove clutter from plots to strive for clean and elegant plots. I highly recommend anyone interested in data visualisations to read the works of Edward Tufte, but one of his most famous opinions is to "Maximise the data-ink ratio, within reason". Through this, Tufte proposes a minimalistic approach to data visualisation by removing most parts of a plot which do not display the data itself. This is certainly one extreme of data visualisation aesthetics, and we should look to find a a middle balance between including too much and too little 'non-data ink' (anything on a chart that doesn't display the actual data).

With gridlines the advice should be:

* Gridlines that run perpendicular to the variable of interest are the most useful
* We do not need gridlines that go from the x axis on a bar chart where the x axis is a category (the bars themselves guide our eye the same way a gridline would).
```{r gg-grid, fig.height = 3, fig.cap = 'Remove x axis gridlines when displaying categorical bdata'}
bar_grid <- tribble(
  ~colA, ~n, 
  "A", 30,
  "B", 20,
  "C", 25,
  "D", 15,
  "E", 10,
  "F", 27
) %>% 
  ggplot(aes(x = reorder(colA, desc(n)), y = n, fill = colA)) +
  geom_col(fill = viridis_pal(option = "viridis")(1)) +
  labs(x = "Message Type",
       y = "Number of posts",
       title = "Unnecessary",
       subtitle = "Unnecessary x-axis gridlines") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5,
                                     colour = "grey50"),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.position = "none")

bar_no_grid <- tribble(
  ~colA, ~n, 
  "A", 30,
  "B", 20,
  "C", 25,
  "D", 15,
  "E", 10,
  "F", 27
) %>% 
  ggplot(aes(x = reorder(colA, desc(n)), y = n, fill = colA)) +
  geom_col(fill = viridis_pal(option = "viridis")(1)) +
  labs(x = "Message Type",
       y = "Number of posts",
       title = "Good",
       subtitle = "x-axis gridlines removed") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5,
                                     colour = "grey50"),
        panel.border = element_blank(),
        panel.grid.major.x = element_blank(),
        axis.line = element_line(),
        legend.position = "none")

bar_grid + bar_no_grid
```

* When the data values are specifically displayed on the chart (as in Figure \@ref(fig:gg-value)) then we do not need gridlines to help interpret these values.
```{r gg-grid-2, fig.height = 3, fig.cap = 'Remove x axis gridlines when displaying categorical bdata'}
bar_no_lab <- tribble(
  ~colA, ~n, 
  "A", 30,
  "B", 20,
  "C", 25,
  "D", 15,
  "E", 10,
  "F", 27
) %>% 
  ggplot(aes(x = reorder(colA, desc(n)), y = n, fill = colA)) +
  geom_col(fill = viridis_pal(option = "viridis")(1)) +
  geom_text(aes(label = n), 
            vjust = 1.5,
            colour = "white",
            size = 4,
            family = "GT Walsheim Pro") +
  labs(x = "Message Type",
       y = "Number of posts",
       title = "Unnecessary",
       subtitle = "y-axis gridlines don't add anything") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line(),
        panel.grid.major.x = element_blank(),
        legend.position = "none")

bar_lab <- tribble(
  ~colA, ~n, 
  "A", 30,
  "B", 20,
  "C", 25,
  "D", 15,
  "E", 10,
  "F", 27
) %>% 
  ggplot(aes(x = reorder(colA, desc(n)), y = n, fill = colA)) +
  geom_col(fill = viridis_pal(option = "viridis")(1)) +
  geom_text(aes(label = n), 
            vjust = 1.5,
            colour = "white",
            size = 4,
            family = "GT Walsheim Pro") +
  labs(x = "Message Type",
       y = "Number of posts",
       title = "Good",
       subtitle = "Values on the plot provide us necessary info") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5,
                                     colour = "grey50"),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.line = element_line(),
        legend.position = "none")

bar_no_lab + bar_lab
```
* Gridlines should not be the same colour as the axis lines or font. A light grey balances utility and overpowering the plot. 
```{r gg-grid-col, fig.cap = 'The difference gridline colours make', fig.height = 3}
plot_1 <- example %>% 
  mutate(created_time = floor_date(created_time,
                                   unit = "day")) %>% 
  count(created_time) %>% 
  ggplot(aes(x = created_time, y = n)) +
  geom_line(colour = viridis_pal(option = "viridis")(1),
            linewidth = 1) +
  labs(x = "Date",
       y = "Number of posts",
       title = "Bad") +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line(),
        panel.grid = element_line(colour = "black"))

plot_2 <- example %>% 
  mutate(created_time = floor_date(created_time,
                                   unit = "day")) %>% 
  count(created_time) %>% 
  ggplot(aes(x = created_time, y = n)) +
  geom_line(colour = viridis_pal(option = "viridis")(1),
            linewidth = 1) +
  labs(x = "Date",
       y = "Number of posts",
       title = "Good") +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.line = element_line())

plot_1 + plot_2
```

The advice surrounding borders:

* If the plot you are making is faceted (i.e. made of up of lots of little plots as in the case of WLO), then a border should be included around each plot to clearly show which data and information in contained in each individual plot.
* If the plot is stand alone, but requires axis, then only the axes of interest (normally x and y axes) should be drawn, with no outer border.
* Plots that do not contain any axes (e.g. a bigram) should not have a border around them.

**Despite this, consistency is the name of the game here. If for whatever reason a client asks for a border to be around a plot (or a border removed), all similar plots in the deck should follow the same aesthetic.**

## Colours

The choice of colours is one of the most important aspect of any good visualisation, with incorrect usage turning a slick visualisation to a hot uninterpretable mess of sadness.

The Capture Intelligence colour palette is based on the `viridis` palette- a series of colour maps designed to improve graphic readability for those with common forms of colour blindness and/or colour vision deficiency. Plus these colours are super pretty. 

Despite this, we are often tasked with using colour palettes that match the client we performing the work for. This section will not inform how to create your own specific colour palette, nor will it go into detailed colour theory, but rather aims to empower you to be able to make appropriate decisions on the best colours to chose for different visualisations. 

Broadly, there are three different types of colour palettes one can use to display different types of data:

* Qualitative
* Diverging
* Sequential

### Qualitative colour palettes

These palettes are best used to represent values of distinct categories that do not have an intrinsic order. As such, they are appropriate for line charts, bar charts, pie charts, doughnut charts.

These colours are different hues (i.e. different colours), and are sometimes called unordered colour scales. In these scales, _no colour is worth more or less than any other colour_.

The default Microsoft colour palette we use is an example of a qualitative (or discrete) colour palette:

```{r qualitative-col, fig.cap = 'Example qualitative colours', fig.height = 2}
msft_cols <- c("#D83B01", # Orange
             "#FFB900", # Yellow
             "#107C10", # Green
             "#008575", # Teal
             "#0078D4", # Blue
             "#8661C5") # Purple,
tribble(
  ~colA, ~x, ~y,
  "Category A", 1, 1,
  "Category B", 2, 1,
  "Category C", 1, 0,
  "Category D", 2, 0,
  "Category E", 1, -1,
  "Category F", 2, -1
) %>% 
  ggplot(aes(x = x, y = y, colour = colA)) +
  geom_point(size = 13) +
  scale_colour_manual(values = msft_cols) +
  lims(x = c(0.6, 3),
       y = c(-1.5, 1.5)) +
  geom_text(aes(label = colA),
            colour = "black",
            hjust = -0.2,
            family = "GT Walsheim Pro",
            size = 9) +
  theme_void() +
  theme(legend.position = "none")
```

### Sequential colour palettes

These palettes use multiple shade variations- effectively going from a light shade to a dark shade. They are suitable for representing numbers that go from low to high. This means that a reader can see a value represented by a "light colour" and inherently understand that this represents a lower value than a "darker colour", without even having to look at a legend yet. 

Whilst you can use only one colour (e.g. light purple to dark purple), using multiple colours (blue to dark purple) increases the colour contrast and makes it easier to distinguish between values.

```{r sequential-col, fig.cap = 'Example sequential colours'}
seq_bin <- data.frame(colors = seq(1, 7),
                      values = seq(1, 7)) %>% 
  ggplot(aes(x = colors, y = 0, fill = factor(values))) +
  geom_tile() +
  scale_fill_viridis_d(direction = -1) +
  labs(title = "Example Sequential Colour Palette - Binned Values") +
  lims(y = c(-1, 1),
       x = c((0.5 - ((7.5-0.5)*0.1)), ((7.5-0.5)*0.1 + 7.5))) +
  theme_void() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.position = "none",
        panel.grid = element_blank())

seq_cont <- data.frame(colors = seq(1, 1000),
                      values = seq(1, 1000)) %>% 
  ggplot(aes(x = colors, y = 0, fill = values)) +
  geom_tile() +
  scale_fill_viridis_c(direction = -1) +
  labs(title = "Example Sequential Colour Palette - Continuous Values") +
  lims(y = c(-1, 1),
       x = c((0.5 - ((1000.5-0.5)*0.1)), ((1000.5-0.5)*0.1 + 1000.5))) +
  theme_void() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.position = "none",
        panel.grid = element_blank())

seq_bin / seq_cont
```

### Diverging colour palettes

These palettes are best used when we want to represent a scale around a central value (i.e. a meaningful middle value such as zero, an average, a threshold, a target etc). Whereas sequential colour palettes go from low to high, diverging palettes utilise a neutral colour in the middle of the scale, with two opposite colours with varying shades diverging from this central value. These palettes are often use to visualise negative and positive values or Likert scales. There are two big advantages to using diverging scales: they emphasize the extremes, and they let readers see more differences in the data.

An example of this could be scores of valence than range from 1 (positive) to -1 (negative) with a central value of 0 (neutral).

```{r divergent-col, fig.cap = 'Example divergent colours'}

div_bin <- data.frame(colors = seq(1, 7),
                      values = seq(-3, 3)) %>% 
  ggplot(aes(x = colors, y = 0, fill = factor(values))) +
  geom_tile() +
  scale_fill_brewer(palette = "PRGn") +
  labs(title = "Example Divergent Colour Palette - Binned Values") +
  lims(y = c(-1, 1),
       x = c((0.5 - ((7.5-0.5)*0.1)), ((7.5-0.5)*0.1 + 7.5))) +
  theme_void() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.position = "none",
        panel.grid = element_blank())

div_cont <- data.frame(colors = seq(1, 1001),
                      values = rev(seq(-500, 500))) %>% 
  ggplot(aes(x = colors, y = 0, fill = values)) +
  geom_tile() +
  scale_fill_distiller(palette = "PRGn") +
  labs(title = "Example Sequential Colour Palette - Continuous Values") +
  lims(y = c(-1, 1),
       x = c((0.5 - ((1000.5-0.5)*0.1)), ((1000.5-0.5)*0.1 + 1000.5))) +
  theme_void() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        panel.border = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.position = "none",
        panel.grid = element_blank())

div_bin / div_cont
```

As you can see, the difference between sequential and divergent palettes is very nuanced (especially with many data values), and deciding between the two should be a considered choice. If you want to emphasise the highest values, use a sequential scale, if you want to emphasise the lowest and highest values, use a diverging scale.

To show why these different palettes are important, let's see them in some example plots:

```{r, col-ex, fig.height = 3, fig.cap = 'When to use qualitative colour palette'}
qual_bar <- tribble(
  ~colA, ~n, 
  "A", 30,
  "B", 20,
  "C", 25,
  "D", 15,
  "E", 10,
  "F", 27
) %>% 
  ggplot(aes(x = colA, y = n, fill = colA)) +
  geom_col() +
  labs(x = "Message Type",
       y = "Number of posts",
       title = "Good",
       subtitle = "Qualitative Palette") +
  scale_fill_manual(values = msft_cols) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, colour = "grey50"),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.position = "none")

seq_bar <- tribble(
  ~colA, ~n, 
  "A", 30,
  "B", 20,
  "C", 25,
  "D", 15,
  "E", 10,
  "F", 27
) %>% 
  ggplot(aes(x = colA, y = n, fill = colA)) +
  geom_col() +
  scale_fill_viridis_d() +
  labs(x = "Message Type",
       y = "Number of posts",
       title = "Not ideal",
       subtitle = "Sequential Palette") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5,
                                     colour = "grey50"),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.position = "none")

div_bar <- tribble(
  ~colA, ~n, 
  "A", 30,
  "B", 20,
  "C", 25,
  "D", 15,
  "E", 10,
  "F", 27
) %>% 
  ggplot(aes(x = colA, y = n, fill = colA)) +
  geom_col() +
  scale_fill_brewer(palette = "PRGn") +
  labs(x = "Message Type",
       y = "Number of posts",
       title = "Bad",
       subtitle = "Divergent Palette") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, colour = "grey50"),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.position = "none")

qual_bar + seq_bar + div_bar
```

Here we see how a simple bar chart can look vastly different when using different palettes. Qualitative colour palettes maximise the distinction between categories making it easy to different groups at a glance. Similarly, the use of a qualitative palette ensure the colours do not imply any inherent ordering or hierarchy. The sequential colour palette unintentionally convey a perceived hierarchy or sequence that doesn't exist and subtle differences in colour shades can make it difficult for viewers to distinguish between different categories. Applying a divergent palette to unrelated categories can create a false sense of order or relationship between them. The stark contrast in colours may also draw attention away from the actual values being compared, leading to misinterpretation or confusion.

Despite this, sometimes using a sequential palette can be okay for such plots when we want to emphasise an underlying order. Remember when we said that we could rearrange a chart so the categorical values follow the order of the variable of interest? In this case, using a sequential colour palette actually helps to double-encode the value of "number of posts" by both position and colour

```{r, col-ex-v2, fig.height = 3, fig.cap = 'When to use qualitative colour palette'}
qual_bar <- tribble(
  ~colA, ~n, 
  "A", 30,
  "B", 20,
  "C", 25,
  "D", 15,
  "E", 10,
  "F", 27
) %>% 
  ggplot(aes(x = reorder(colA, desc(n)), y = n, fill = colA)) +
  geom_col() +
  labs(x = "Message Type",
       y = "Number of posts",
       title = "Fine",
       subtitle = "Qualitative Palette") +
  scale_fill_manual(values = msft_cols) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, colour = "grey50"),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.position = "none")

seq_bar <- tribble(
  ~colA, ~n, 
  "A", 30,
  "B", 20,
  "C", 25,
  "D", 15,
  "E", 10,
  "F", 27
) %>% 
  ggplot(aes(x = reorder(colA, desc(n)), y = n, fill = colA)) +
  geom_col() +
  scale_fill_viridis_d() +
  labs(x = "Message Type",
       y = "Number of posts",
       title = "Good",
       subtitle = "Sequential Palette") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5,
                                     colour = "grey50"),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.position = "none")

div_bar <- tribble(
  ~colA, ~n, 
  "A", 30,
  "B", 20,
  "C", 25,
  "D", 15,
  "E", 10,
  "F", 27
) %>% 
  ggplot(aes(x = reorder(colA, desc(n)), y = n, fill = colA)) +
  geom_col() +
  scale_fill_brewer(palette = "PRGn") +
  labs(x = "Message Type",
       y = "Number of posts",
       title = "Bad",
       subtitle = "Divergent Palette") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, colour = "grey50"),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.position = "none")

qual_bar + seq_bar + div_bar
```

Here we can see that to be honest the sequential bar chart with the sequential palette is easier to read than the colourful and overwhelming qualitative palette.

Below is another example, this time visualising a heatmap. We can see the value we are visualising with colour (percentage) has a clear order. Using our qualitative palette, which has no inherent order, produces a lego-like mess where it is not clear what each colour represents. The divergent palette is slightly better, but still creates the impression there is a significant distinction between 10% and 40%, when in fact they form a continuous range. The best approach here is the sequential palette that provides a smooth progression of colours to represent the increasing percentages. This ensures a more accurate representation of the data and help users perceive the gradual change in values without introducing unnecessary confusion or bias.

```{r, col-ex-2, fig.height = 3, fig.cap = 'When to use sequential colour palette'}
x <- LETTERS[1:7]
y <- paste0("var", seq(1, 4))

set.seed(1234)
data <- expand.grid(x = x, y = y) %>%
  mutate(z = runif(28, 1, 6),
         z = round(z, 0),
         z = paste0(z*10, "%"))

qual_heatmap <- data %>% 
ggplot(aes(x, y, fill = factor(z))) + 
  geom_tile() +
  labs(x = "Topic",
       y = "Platform",
       fill = NULL,
       title = "Bad",
       subtitle = "Qualitative Palette") +
  scale_fill_manual(values = msft_cols,
                    guide = guide_legend(label.position = "bottom",
                                         nrow = 1)) +
  coord_fixed() +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, colour = "grey50"),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.key.height = unit(0.4, "cm"),  
        legend.key.width = unit(0.8, "cm"),
        legend.position = "bottom",
        legend.spacing.x = unit(0, 'cm'),
        legend.text = element_text(size = 7))

seq_heatmap <- data %>% 
ggplot(aes(x, y, fill = factor(z))) + 
  geom_tile() +
  labs(x = "Topic",
       y = "Platform",
       fill = NULL,
       title = "Good",
       subtitle = "Sequential Palette") +
  scale_fill_viridis_d(direction = -1,
                       guide = guide_legend(label.position = "bottom",
                                            nrow = 1)) +
  coord_fixed() +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, colour = "grey50"),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.key.height = unit(0.4, "cm"),  
        legend.key.width = unit(0.8, "cm"),
        legend.position = "bottom",
        legend.spacing.x = unit(0, 'cm'),
        legend.text = element_text(size = 7))

div_heatmap <- data %>% 
ggplot(aes(x, y, fill = factor(z))) + 
  geom_tile() +
  labs(x = "Topic",
       y = "Platform",
       fill = NULL,
       title = "Not ideal",
       subtitle = "Divergent Palette") +
  scale_fill_brewer(palette = "PRGn",
                    guide = guide_legend(label.position = "bottom",
                                         nrow = 1)) +
  coord_fixed() +
  theme_bw() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, colour = "grey50"),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.key.height = unit(0.4, "cm"),  
        legend.key.width = unit(0.8, "cm"),
        legend.position = "bottom",
        legend.spacing.x = unit(0, 'cm'),
        legend.text = element_text(size = 7))

qual_heatmap + seq_heatmap + div_heatmap
```

Despite being "text" rather than "numbers, something like a Likert scale has inherent order to it and hence a qualitative colour palette is unsuitable for this particular visualization. Whilst this palette enables easy differentiation between groups at a glance, it fails to represent the underlying scale or intensity of the Likert scale. The sequential colour palette is also unsuitable. Its subtle differences in colour shades can make it challenging for viewers to distinguish between the different categories accurately. The sequential palette may inadvertently suggest a progression or intensity within the Likert scale, misleading the interpretation of the data. In contrast, the divergent colour palette can be considered suitable for the Likert scale stacked bar charts. By using a divergent palette, meaningful thresholds or midpoints within the scale can be highlighted effectively. It enables the representation of both positive and negative values, accentuating the contrast between categories. 

```{r, col-ex-3, fig.height = 4, fig.cap = 'When to use divergent colour palette'}
likert <- data.frame(sentiment = rep(c("Highly Negative", "Quite Negative",
                                        "Neutral", "Quite Positive", "Very Positive"), 4),
                          category = rep(LETTERS[1:4], each = , times = 1),
                          n = runif(20, 10, 90)) %>% 
  group_by(category) %>% 
  mutate(prop = n/sum(n) * 100) %>% 
  ungroup() %>% 
  mutate(sentiment = factor(sentiment, levels = rev(c("Highly Negative", "Quite Negative", "Neutral", "Quite Positive", "Very Positive"))))

qual_likert <- likert %>% 
ggplot(aes(x = fct_rev(category), y = prop, fill = sentiment)) +
  geom_bar(position = "stack", stat = "identity",
           width = 0.6) +
  labs(x = "Category",
       y = "Number of posts classified per topic",
       title = "Bad",
       subtitle = "Qualitative Palette",
       fill = NULL) +
  scale_fill_manual(values = msft_cols,
                    guide = guide_legend(ncol = 1)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  coord_flip() +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, colour = "grey50"),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.key.height = unit(0.4, "cm"),  
        legend.key.width = unit(0.4, "cm"),
        legend.text = element_text(size = 7),
        legend.position = "bottom")

seq_likert <- likert %>% 
ggplot(aes(x = fct_rev(category), y = prop, fill = sentiment)) +
  geom_bar(position = "stack", stat = "identity",
           width = 0.6) +
  labs(x = "Category",
       y = "Number of posts classified per topic",
       title = "Bad",
       subtitle = "Sequential Palette",
       fill = NULL) +
  scale_fill_viridis_d(direction = -1,
                    guide = guide_legend(ncol = 1)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  coord_flip() +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, colour = "grey50"),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.key.height = unit(0.4, "cm"),  
        legend.key.width = unit(0.4, "cm"),
        legend.text = element_text(size = 7),
        legend.position = "bottom")

div_likert <- likert %>% 
ggplot(aes(x = fct_rev(category), y = prop, fill = sentiment)) +
  geom_bar(position = "stack", stat = "identity",
           width = 0.6) +
  labs(x = "Category",
       y = "Number of posts classified per topic",
       subtitle = "Divergent Palette",
       title = "Good",
       fill = NULL) +
  scale_fill_brewer(palette = "PRGn",
                    direction = -1,
                    guide = guide_legend(ncol = 1)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  coord_flip() +
  theme_bw() +
  scale_colour_viridis_c() +
  theme(text = element_text(family = "GT Walsheim Pro"),
        plot.title = element_text(size = 15, hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, colour = "grey50"),
        panel.border = element_blank(),
        axis.line = element_line(),
        legend.key.height = unit(0.4, "cm"),  
        legend.key.width = unit(0.4, "cm"),
        legend.text = element_text(size = 7),
        legend.position = "bottom")

qual_likert + seq_likert + div_likert
```

## Highlighting important data - WIP
